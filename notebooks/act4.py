# -*- coding: utf-8 -*-
"""Act4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XZ-07ZOIa3qCkaSF-5B7_hAB3RsC2vEd
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import json

pd.options.display.max_columns = 50
pd.options.display.max_colwidth = 200

import pandas as pd
from pathlib import Path  # ‚úÖ Importamos Path para manejar rutas de archivos

# üìÅ Definimos la ruta del archivo Excel que contiene los datos
file_path = 'online_retail_II.xlsx'

# üß© Verificamos si el archivo existe en el entorno actual (por ejemplo, en Google Colab)
if not Path(file_path).exists():
    print(f'‚ö†Ô∏è No se encontr√≥ el archivo: {file_path}. Sube el archivo a Colab o cambia la ruta de acceso.')
else:
    # üìä Leemos las hojas correspondientes a los a√±os 2009-2010 y 2010-2011
    df1 = pd.read_excel(file_path, sheet_name='Year 2009-2010')
    df2 = pd.read_excel(file_path, sheet_name='Year 2010-2011')

    # üîó Unimos ambos DataFrames en uno solo, ignorando los √≠ndices originales
    df = pd.concat([df1, df2], ignore_index=True)

    # ‚úÖ Confirmamos la carga mostrando el n√∫mero de filas y columnas
    print('‚úÖ Dataset cargado correctamente.')
    print('üìè Filas:', df.shape[0], '| Columnas:', df.shape[1])

    # üëÄ Mostramos las primeras filas para inspeccionar los datos
    display(df.head())

# üßæ Informaci√≥n general del DataFrame
try:
    # üìè Mostramos las dimensiones del dataset (filas y columnas)
    print('Shape:', df.shape)

    # üß¨ Mostramos los tipos de datos de cada columna (num√©rico, texto, fecha, etc.)
    print('\nTipos de datos:')
    display(df.dtypes)

    # üëÄ Mostramos las primeras filas del DataFrame para una vista previa del contenido
    print('\nPrimeras filas:')
    display(df.head())

# ‚ö†Ô∏è Si el DataFrame 'df' no existe (por ejemplo, no se ejecut√≥ la celda anterior), se muestra un mensaje de advertencia
except NameError:
    print('‚ö†Ô∏è Ejecuta primero la celda donde se lee el archivo para crear el DataFrame "df".')

# üìä Exploraci√≥n inicial del DataFrame
# En esta celda revisamos la estructura general del conjunto de datos (shape, tipos de columnas y primeras filas)

try:
    # üìè Mostramos la forma del DataFrame: n√∫mero de filas y columnas
    print('Shape:', df.shape)

    # üß¨ Mostramos los tipos de datos de cada columna (por ejemplo: int, float, object, datetime, etc.)
    print('\nTipos de datos:')
    display(df.dtypes)

    # üëÄ Visualizamos las primeras filas del DataFrame para entender su contenido
    print('\nPrimeras filas:')
    display(df.head())

# ‚ö†Ô∏è Si el DataFrame 'df' no existe (por ejemplo, si no se ejecut√≥ la celda anterior),
# se captura el error NameError y se muestra un mensaje de aviso.
except NameError:
    print('‚ö†Ô∏è Ejecuta primero la celda donde se lee el archivo para crear el DataFrame "df".')

# üß© Asegurar los tipos de datos correctos en las columnas principales

# üìÖ Convertimos la columna 'InvoiceDate' a formato datetime (fecha y hora)
# Si hay valores no v√°lidos, se transforman en NaT (valores nulos de fecha)
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'], errors='coerce')

# üí∞ Verificamos qu√© columna existe para representar el precio de los productos
if 'UnitPrice' in df.columns:
    # Si existe 'UnitPrice', la convertimos a tipo num√©rico
    df['UnitPrice'] = pd.to_numeric(df['UnitPrice'], errors='coerce')
elif 'Price' in df.columns:
    # Si el dataset usa 'Price' en lugar de 'UnitPrice', la renombramos para mantener consistencia
    df['UnitPrice'] = pd.to_numeric(df['Price'], errors='coerce')
else:
    # Si no existe ninguna columna de precio, mostramos advertencia
    print("‚ö†Ô∏è No se encontr√≥ ninguna columna de precio ('UnitPrice' o 'Price'). Verifica los nombres de las columnas del dataset.")

# üì¶ Convertimos la columna 'Quantity' a tipo num√©rico
# Esto asegura que los valores puedan usarse en operaciones matem√°ticas
df['Quantity'] = pd.to_numeric(df['Quantity'], errors='coerce')

# üè∑Ô∏è Definimos algunas columnas como categ√≥ricas (texto/etiquetas)
# Esto ayuda a optimizar memoria y mejorar interpretabilidad en an√°lisis
for col in ['InvoiceNo', 'StockCode', 'Description', 'Country', 'CustomerID']:
    if col in df.columns:
        df[col] = df[col].astype('object')

# ‚úÖ Mostramos los tipos de datos resultantes despu√©s de la conversi√≥n
print('‚úÖ Tipos despu√©s de la conversi√≥n:')
display(df.dtypes)

# üíµ Crear la columna 'TotalPrice'
# Calculamos el precio total de cada transacci√≥n multiplicando la cantidad por el precio unitario

df['TotalPrice'] = df['Quantity'] * df['UnitPrice']

# üëÄ Mostramos las primeras filas de las columnas m√°s relevantes para confirmar el c√°lculo
display(df[['Quantity', 'UnitPrice', 'TotalPrice']].head())

# Histograma: Quantity
plt.figure(figsize=(8,4))
df['Quantity'].dropna().hist(bins=100)
plt.title('Histograma - Quantity')
plt.xlabel('Quantity')
plt.ylabel('Frecuencia')
plt.show()

# Histograma: Quantity
plt.figure(figsize=(8,4))
df['Quantity'].dropna().hist(bins=100)
plt.title('Histograma - Quantity')
plt.xlabel('Quantity')
plt.ylabel('Frecuencia')
plt.show()

# Histograma: UnitPrice
plt.figure(figsize=(8,4))
df['UnitPrice'].dropna().hist(bins=100)
plt.title('Histograma - UnitPrice')
plt.xlabel('UnitPrice')
plt.ylabel('Frecuencia')
plt.show()

# Histograma: TotalPrice
plt.figure(figsize=(8,4))
df['TotalPrice'].dropna().hist(bins=100)
plt.title('Histograma - TotalPrice')
plt.xlabel('TotalPrice')
plt.ylabel('Frecuencia')
plt.show()

# Boxplot: Quantity
plt.figure(figsize=(8,3))
plt.boxplot(df['Quantity'].dropna(), vert=False)
plt.title('Boxplot - Quantity')
plt.xlabel('Quantity')
plt.show()

# Boxplot: UnitPrice
plt.figure(figsize=(8,3))
plt.boxplot(df['UnitPrice'].dropna(), vert=False)
plt.title('Boxplot - UnitPrice')
plt.xlabel('UnitPrice')
plt.show()

# Boxplot: TotalPrice
plt.figure(figsize=(8,3))
plt.boxplot(df['TotalPrice'].dropna(), vert=False)
plt.title('Boxplot - TotalPrice')
plt.xlabel('TotalPrice')
plt.show()

# Top 10 categor√≠as por n√∫mero de facturas (usando el nombre correcto de la columna)
top_categories = df.groupby('Description')['Invoice'].nunique().sort_values(ascending=False).head(10)

plt.figure(figsize=(10,5))
sns.barplot(x=top_categories.values, y=top_categories.index)
plt.title("Top 10 Categor√≠as por n√∫mero de facturas")
plt.xlabel("N√∫mero de facturas √∫nicas")
plt.ylabel("Categor√≠a (Description)")
plt.show()

# Top 10 StockCode
top_stock = df['StockCode'].value_counts().head(10)
plt.figure(figsize=(8,4))
top_stock.plot(kind='bar')
plt.title('Top 10 StockCode')
plt.xlabel('StockCode')
plt.ylabel('Conteo')
plt.show()

# Top 10 Description (productos m√°s frecuentes)
top_desc = df['Description'].value_counts().head(10)
plt.figure(figsize=(10,4))
top_desc.plot(kind='bar')
plt.title('Top 10 Description')
plt.xlabel('Description')
plt.ylabel('Conteo')
plt.show()

# 1) Nulos por columna (%)
nulls = df.isnull().mean()*100
display(pd.DataFrame({'columna': nulls.index, 'pct_null': nulls.values}).sort_values('pct_null', ascending=False).reset_index(drop=True))

# 2) Duplicados exactos (filas id√©nticas)
total_rows = df.shape[0]
exact_dups = df.duplicated(keep=False).sum()
print('Filas totales:', total_rows)
print('Filas que tienen duplicados exactos (count):', exact_dups)
print('Filas duplicadas (drop duplicates keep=first):', df.duplicated().sum())

# 3) Outliers ‚Äî m√©todo IQR para Quantity y UnitPrice
def detect_iqr_outliers(series):
    q1 = series.quantile(0.25)
    q3 = series.quantile(0.75)
    iqr = q3 - q1
    lower = q1 - 1.5*iqr
    upper = q3 + 1.5*iqr
    return (series < lower) | (series > upper), lower, upper

for col in ['Quantity','UnitPrice']:
    s = df[col].dropna()
    out_mask, low, high = detect_iqr_outliers(s)
    pct_out = out_mask.mean()*100
    print(f'{col}: IQR lower={low}, upper={high}, % outliers (aprox)={pct_out:.4f}')

# Conteo antes de limpieza
before = df.shape[0]

# 1) Duplicados exactos: eliminar y mostrar conteo antes/despu√©s
exact_before = df.duplicated().sum()
df_no_exact_dup = df.drop_duplicates(keep='first')
exact_after = df_no_exact_dup.duplicated().sum()
print('Duplicados exactos - antes:', exact_before, 'despu√©s (deber√≠a ser 0):', exact_after)

# 2) Duplicados por clave: usando ['InvoiceNo','StockCode','InvoiceDate','CustomerID']
key_cols = ['InvoiceNo','StockCode','InvoiceDate','CustomerID']
key_cols = [c for c in key_cols if c in df_no_exact_dup.columns]
dup_by_key_before = df_no_exact_dup.duplicated(subset=key_cols).sum()
# criterio: conservar la fila con UnitPrice != 0 y, si hay empate, la m√°s reciente (mayor InvoiceDate)
def dedup_by_key(df_):
    # ordenar por InvoiceDate asc para que keep='last' conserve la m√°s reciente
    if 'InvoiceDate' in df_.columns:
        df_sorted = df_.sort_values('InvoiceDate')
    else:
        df_sorted = df_.copy()
    # priorizar filas con UnitPrice != 0: crear helper key
    if 'UnitPrice' in df_sorted.columns:
        df_sorted['_price_nonzero'] = (df_sorted['UnitPrice'] != 0).astype(int)
        # ordenar por price_nonzero then InvoiceDate
        df_sorted = df_sorted.sort_values(['_price_nonzero'], ascending=False)
    deduped = df_sorted.drop_duplicates(subset=key_cols, keep='first').drop(columns=[c for c in ['_price_nonzero'] if c in df_sorted.columns])
    return deduped

df_dedup_key = dedup_by_key(df_no_exact_dup)
dup_by_key_after = df_dedup_key.duplicated(subset=key_cols).sum()
print('Duplicados por clave - antes:', dup_by_key_before, 'despu√©s:', dup_by_key_after)

after = df_dedup_key.shape[0]
print('\nFilas antes de limpieza total:', before, 'despu√©s:', after)

# 3) CustomerID faltantes: cuantificar impacto de eliminarlas
if 'CustomerID' in df_dedup_key.columns:
    total = df_dedup_key.shape[0]
    missing_cust = df_dedup_key['CustomerID'].isnull().sum()
    pct_missing = missing_cust/total*100
    print('Filas totales:', total)
    print('Filas sin CustomerID:', missing_cust, f'({pct_missing:.2f}%)')
    # crear dataset sin CustomerID
    df_no_missing_cust = df_dedup_key.dropna(subset=['CustomerID'])
    print('Filas si eliminamos filas sin CustomerID:', df_no_missing_cust.shape[0])
else:
    print('No hay columna CustomerID en el dataset.')

"""Parte 4 ‚Äî Data Contract"""

# Data Contract b√°sico (ejemplo en JSON)
data_contract = {
    'InvoiceNo': {
        'type': 'string',
        'nullable': False,
        'constraints': {
            'pattern': '^\\w+',
            'notes': 'Si comienza con C indica cancelaci√≥n (ej: C12345)'
        }
    },
    'InvoiceDate': {
        'type': 'datetime',
        'nullable': False,
        'constraints': {
            'format': 'ISO 8601',
            'notes': 'Rango esperado: 2009-12-01 a 2011-12-09'
        }
    },
    'StockCode': {'type': 'string', 'nullable': False},
    'Description': {'type': 'string', 'nullable': True},
    'Quantity': {
        'type': 'integer',
        'nullable': False,
        'constraints': {'min': None, 'notes': 'Valores negativos indican devoluciones'}
    },
    'UnitPrice': {
        'type': 'float',
        'nullable': False,
        'constraints': {'min': 0.0}
    },
    'CustomerID': {'type': 'string', 'nullable': True}
}

# Guardar el data contract y el dataset limpio
out_dir = Path('/content') if Path('/content').exists() else Path('/mnt/data')
out_dir = out_dir
clean_csv = out_dir / 'online_retail_clean.csv'
contract_file = out_dir / 'data_contract_online_retail.json'
df_dedup_key.to_csv(clean_csv, index=False)
with open(contract_file, 'w', encoding='utf-8') as f:
    json.dump(data_contract, f, indent=2, ensure_ascii=False)

print('Archivo CSV limpio guardado en:', clean_csv)
print('Data contract guardado en:', contract_file)

"""
Parte 5 ‚Äî Conclusiones
"""

# Tabla resumen antes/despu√©s
summary = {
    'metric': ['filas_totales','duplicados_exactos_before','duplicados_exactos_after','duplicados_por_clave_before','duplicados_por_clave_after','filas_sin_customerID_pct_before'],
    'value': [
        int(before),
        int(exact_before),
        int(exact_after),
        int(dup_by_key_before),
        int(dup_by_key_after),
        float((df['CustomerID'].isnull().sum()/df.shape[0])*100) if 'CustomerID' in df.columns else None
    ]
}
summary_df = pd.DataFrame(summary)
display(summary_df)